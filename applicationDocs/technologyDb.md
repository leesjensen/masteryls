# MasteryLS Database Technology

## Schema

![Database schema](databaseSchema.png)

## User

Let a user manage their own user record so that they can register, login, and update settings

```postgres
create table public."user" (
  id uuid not null references auth.users(id) on delete cascade,
  "createdAt" timestamp with time zone default now(),
  name text,
  email text,
  settings jsonb default '{}'::jsonb,

  primary key (id)
);

alter table public."user" enable row level security;
```

```postgres
CREATE policy "User manage self"
on "public"."user"
FOR ALL
TO public
using (
  (auth.uid() = id)
)
with check (
  (auth.uid() = id)
);
```

```postgres
CREATE POLICY "Editor reads all users"
ON public."user"
FOR SELECT
TO authenticated
USING (public.auth_is_editor(auth.uid()));
```

## Role

Allow user to read their own roles

```postgres
create table public.role (
  id bigint generated by default as identity primary key, -- int8 with auto-increment
  "createdAt" timestamp with time zone default now(),
  "user" uuid references auth.users(id) on delete cascade,
  "right" varchar,
  object uuid references public.catalog(id) on delete cascade
  settings jsonb default '{}'::jsonb
);

alter table public."user" enable row level security;
```

```postgres
CREATE POLICY "User read self"
  ON public.role
  FOR SELECT
  TO public
  USING (
  ("user" = auth.uid())
  );
```

## Catalog

Everyone can read the catalog including unauthenticated users so that they can view courses in **read-only** mode.

```postgres
create table public.catalog (
  id uuid primary key default gen_random_uuid(),
  "createdAt" timestamp with time zone default now(),
  title text,
  description text,
  name text,
  "gitHub" jsonb default '{}'::jsonb,
  settings jsonb default '{}'::jsonb
);
```

```postgres
CREATE policy "User read all"
on "public"."catalog"
FOR ALL
TO public
using (
  true
);
```

## Enrollment

Let a user manage their own enrollment record so that they can join, drop, and update settings

```postgres
create table public.enrollment (
  id uuid primary key default gen_random_uuid(),
  "createdAt" timestamp with time zone default now(),
  "learnerId" uuid references public."user"(id) on delete cascade,
  "catalogId" uuid references public.catalog(id) on delete cascade,
  progress jsonb default '{}'::jsonb,
  settings jsonb default '{}'::jsonb
);
```

```postgres
CREATE policy "User manage self"
on "public"."enrollment"
FOR ALL
TO public
using (
  (auth.uid() = "learnerId")
)
with check (
  (auth.uid() = "learnerId")
);
```

## Progress

```postgres
create table public.progress (
  id uuid primary key default gen_random_uuid(),
  "createdAt" timestamp with time zone default now(),
  "userId" uuid references public."user"(id) on delete cascade,
  "enrollmentId" uuid references public.enrollment(id) on delete cascade,
  "catalogId" uuid references public.catalog(id) on delete cascade,
  "topicId" uuid references public.topic(id) on delete cascade,
  "interactionId" uuid, -- ID of specific quiz/video interaction if needed
  duration integer, -- int4
  type varchar,
  details jsonb default '{}'::jsonb
);
```

```postgres
CREATE POLICY "Allow users to insert their own progress"
ON "public"."progress"
FOR INSERT TO authenticated
WITH CHECK ((SELECT auth.uid()) = "userId");
```

```postgres
CREATE POLICY "Allow users to read their own progress"
ON "public"."progress"
FOR SELECT TO authenticated
USING ((SELECT auth.uid()) = "userId");
```

```postgres
CREATE POLICY "Editor reads all users progress"
ON public."progress"
FOR SELECT
TO authenticated
USING (public.auth_is_editor(auth.uid()));
```

## Topic

Full content of every topic. Used for free text search. This is a cache of the content that is stored in GitHub and is updated whenever a topic is committed to GitHub.

### Create table

```postgres
create table topic (
  id uuid primary key,
  "catalogId" uuid references public.catalog(id) on delete cascade
  content text not null,
  ftsContent tsvector generated always as (to_tsvector('english', ' ' || content)) stored,
  updatedAt timestamp with time zone default now()
);
create index topicFtsIdx on topic using gin (ftsContent);

alter table public.topic enable row level security;
```

#### Trigger to update the date

```
create or replace function updateModifiedColumn()
returns trigger as $$
begin
    new.updatedAt = now();
    return new;
end;
$$ language 'plpgsql';

create trigger updateTopicModtime
    before update on topic
    for each row
    execute procedure updateModifiedColumn();
```

#### Remote procedure call for free text searching

```postgres
create or replace function search_topics(search_query text, target_catalog_id uuid default null)
returns table (
  id uuid,
  catalogId uuid,
  headline text,
  rank real
) as $$
begin
  return query
  select
    t.id,
    t."catalogId",
    ts_headline('english', t.content, websearch_to_tsquery('english', search_query), 'StartSel="<mark>", StopSel="</mark>", MaxWords=10, MinWords=5, MaxFragments=3, FragmentDelimiter=" ... "') as headline,
    ts_rank(t.ftscontent, websearch_to_tsquery('english', search_query)) as rank
  from topic t
  where t.ftscontent @@ websearch_to_tsquery('english', search_query) and (target_catalog_id is null or t."catalogId" = target_catalog_id)
  order by rank desc;
end;
$$ language plpgsql;
```

```postgres
create policy "User read all"
on public.topic
for select       -- Restrict to Read-only
to authenticated -- Only logged-in users
using (true);    -- No specific row filters, allow all row

CREATE POLICY "Root manages all"
ON public.topic
FOR ALL
TO authenticated
USING (public.auth_is_root(auth.uid()))
WITH CHECK (public.auth_is_root(auth.uid()));
```

### Insert

```js
const { data, error } = await supabase.from('topic').insert([
  {
    id: 'your-provided-uuid-here',
    body: 'In this lesson, we learn about tables...',
  },
]);
```

### Query

```js
const { data, error } = await supabase.rpc('search_topics', { search_query: 'we learn', target_catalog_id: '32' });
```

### Update

```js
const { data, error } = await supabase.from('topic').update({ content: 'Updated instructional content.' }).eq('id', 'your-provided-uuid-here');
```

### Role based access

Create a function that validates a user is root. You can then call this in RLS policies

```postgres
CREATE OR REPLACE FUNCTION public.auth_is_root(uid uuid)
RETURNS boolean
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT EXISTS (
    SELECT 1
    FROM public.role
    WHERE "user" = uid
      AND "right" = 'root'
  );
$$;

GRANT EXECUTE ON FUNCTION public.auth_is_root(uuid) TO anon, authenticated;
```

Create a function that validates a user has the editor role

```postgres
CREATE OR REPLACE FUNCTION public.auth_is_editor(uid uuid)
RETURNS boolean
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT EXISTS (
    SELECT 1
    FROM public.role
    WHERE "user" = uid
      AND "right" = 'editor'
  );
$$;

GRANT EXECUTE ON FUNCTION public.auth_is_editor(uuid) TO anon, authenticated;
```

Create a policy on each table that allows root to manage everything

```postgres
CREATE POLICY "Root manages all"
ON public.catalog
FOR ALL
TO public
USING (public.auth_is_root(auth.uid()))
WITH CHECK (public.auth_is_root(auth.uid()));
```

You can allow update for specific columns by restricting the update with a GRANT

```postgres
DROP POLICY IF EXISTS "update-own-rows" ON public.role;
CREATE POLICY "update-own-rows"
  ON public.role
  FOR UPDATE
  USING (user = auth.uid())
  WITH CHECK (user = auth.uid());

REVOKE ALL PRIVILEGES ON public.role FROM authenticated;

GRANT SELECT ON public.role TO authenticated;
GRANT INSERT ON public.role TO authenticated;
GRANT DELETE ON public.role TO authenticated;
GRANT UPDATE (settings) ON public.role TO authenticated;
```
